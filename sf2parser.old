// Basic SF2 Parser for Web Audio
// Supports reading presets and sample data from SF2 files

export class SF2Parser {
    constructor(arrayBuffer) {
        this.data = new DataView(arrayBuffer);
        this.buffer = arrayBuffer;
        this.presets = [];
        this.instruments = [];
        this.samples = [];
        this.sampleData = null;
    }

    parse() {
        // Check RIFF header
        const riff = this.readFourCC(0);
        if (riff !== 'RIFF') {
            throw new Error('Not a valid RIFF file');
        }

        const fileSize = this.data.getUint32(4, true);
        const sfbk = this.readFourCC(8);
        if (sfbk !== 'sfbk') {
            throw new Error('Not a valid SF2 file');
        }

        // Parse chunks
        let offset = 12;
        while (offset < fileSize + 8) {
            const chunkId = this.readFourCC(offset);
            const chunkSize = this.data.getUint32(offset + 4, true);

            if (chunkId === 'LIST') {
                const listType = this.readFourCC(offset + 8);
                if (listType === 'sdta') {
                    this.parseSdta(offset + 12, chunkSize - 4);
                } else if (listType === 'pdta') {
                    this.parsePdta(offset + 12, chunkSize - 4);
                }
            }

            offset += 8 + chunkSize;
            if (chunkSize % 2 === 1) offset++; // Pad byte
        }

        return {
            presets: this.presets,
            instruments: this.instruments,
            samples: this.samples,
            sampleData: this.sampleData
        };
    }

    readFourCC(offset) {
        return String.fromCharCode(
            this.data.getUint8(offset),
            this.data.getUint8(offset + 1),
            this.data.getUint8(offset + 2),
            this.data.getUint8(offset + 3)
        );
    }

    readString(offset, length) {
        let str = '';
        for (let i = 0; i < length; i++) {
            const char = this.data.getUint8(offset + i);
            if (char === 0) break;
            str += String.fromCharCode(char);
        }
        return str;
    }

    parseSdta(offset, size) {
        // Sample data chunk
        const end = offset + size;
        while (offset < end) {
            const subId = this.readFourCC(offset);
            const subSize = this.data.getUint32(offset + 4, true);

            if (subId === 'smpl') {
                // 16-bit sample data
                this.sampleData = new Int16Array(this.buffer, offset + 8, subSize / 2);
            }

            offset += 8 + subSize;
            if (subSize % 2 === 1) offset++;
        }
    }

    parsePdta(offset, size) {
        // Preset data chunk
        const end = offset + size;
        const chunks = {};

        while (offset < end) {
            const subId = this.readFourCC(offset);
            const subSize = this.data.getUint32(offset + 4, true);
            chunks[subId] = { offset: offset + 8, size: subSize };
            offset += 8 + subSize;
            if (subSize % 2 === 1) offset++;
        }

        // Parse preset headers (phdr)
        if (chunks.phdr) {
            const count = chunks.phdr.size / 38;
            for (let i = 0; i < count - 1; i++) { // Last is EOP
                const off = chunks.phdr.offset + i * 38;
                this.presets.push({
                    name: this.readString(off, 20),
                    preset: this.data.getUint16(off + 20, true),
                    bank: this.data.getUint16(off + 22, true),
                    bagIndex: this.data.getUint16(off + 24, true)
                });
            }
        }

        // Parse instrument headers (inst)
        if (chunks.inst) {
            const count = chunks.inst.size / 22;
            for (let i = 0; i < count - 1; i++) {
                const off = chunks.inst.offset + i * 22;
                this.instruments.push({
                    name: this.readString(off, 20),
                    bagIndex: this.data.getUint16(off + 20, true)
                });
            }
        }

        // Parse sample headers (shdr)
        if (chunks.shdr) {
            const count = chunks.shdr.size / 46;
            for (let i = 0; i < count - 1; i++) {
                const off = chunks.shdr.offset + i * 46;
                this.samples.push({
                    name: this.readString(off, 20),
                    start: this.data.getUint32(off + 20, true),
                    end: this.data.getUint32(off + 24, true),
                    loopStart: this.data.getUint32(off + 28, true),
                    loopEnd: this.data.getUint32(off + 32, true),
                    sampleRate: this.data.getUint32(off + 36, true),
                    originalPitch: this.data.getUint8(off + 40),
                    pitchCorrection: this.data.getInt8(off + 41),
                    sampleType: this.data.getUint16(off + 44, true)
                });
            }
        }

        // Parse bags and generators for zone mapping
        this.parseBagsAndGenerators(chunks);
    }

    parseBagsAndGenerators(chunks) {
        // Parse preset bags (pbag)
        const presetBags = [];
        if (chunks.pbag) {
            const count = chunks.pbag.size / 4;
            for (let i = 0; i < count; i++) {
                const off = chunks.pbag.offset + i * 4;
                presetBags.push({
                    genIndex: this.data.getUint16(off, true),
                    modIndex: this.data.getUint16(off + 2, true)
                });
            }
        }

        // Parse preset generators (pgen)
        const presetGens = [];
        if (chunks.pgen) {
            const count = chunks.pgen.size / 4;
            for (let i = 0; i < count; i++) {
                const off = chunks.pgen.offset + i * 4;
                presetGens.push({
                    oper: this.data.getUint16(off, true),
                    amount: this.data.getInt16(off + 2, true)
                });
            }
        }

        // Parse instrument bags (ibag)
        const instBags = [];
        if (chunks.ibag) {
            const count = chunks.ibag.size / 4;
            for (let i = 0; i < count; i++) {
                const off = chunks.ibag.offset + i * 4;
                instBags.push({
                    genIndex: this.data.getUint16(off, true),
                    modIndex: this.data.getUint16(off + 2, true)
                });
            }
        }

        // Parse instrument generators (igen)
        const instGens = [];
        if (chunks.igen) {
            const count = chunks.igen.size / 4;
            for (let i = 0; i < count; i++) {
                const off = chunks.igen.offset + i * 4;
                instGens.push({
                    oper: this.data.getUint16(off, true),
                    amount: this.data.getInt16(off + 2, true)
                });
            }
        }

        // Link presets to instruments
        for (let i = 0; i < this.presets.length; i++) {
            const preset = this.presets[i];
            const bagStart = preset.bagIndex;
            const bagEnd = i + 1 < this.presets.length ? this.presets[i + 1].bagIndex : presetBags.length - 1;

            preset.zones = [];
            for (let b = bagStart; b < bagEnd; b++) {
                const genStart = presetBags[b].genIndex;
                const genEnd = b + 1 < presetBags.length ? presetBags[b + 1].genIndex : presetGens.length;

                const zone = { generators: {} };
                for (let g = genStart; g < genEnd; g++) {
                    const gen = presetGens[g];
                    zone.generators[gen.oper] = gen.amount;
                }

                // Generator 41 is instrument index
                if (zone.generators[41] !== undefined) {
                    zone.instrumentIndex = zone.generators[41];
                }
                preset.zones.push(zone);
            }
        }

        // Link instruments to samples
        for (let i = 0; i < this.instruments.length; i++) {
            const inst = this.instruments[i];
            const bagStart = inst.bagIndex;
            const bagEnd = i + 1 < this.instruments.length ? this.instruments[i + 1].bagIndex : instBags.length - 1;

            inst.zones = [];
            for (let b = bagStart; b < bagEnd; b++) {
                const genStart = instBags[b].genIndex;
                const genEnd = b + 1 < instBags.length ? instBags[b + 1].genIndex : instGens.length;

                const zone = { generators: {} };
                for (let g = genStart; g < genEnd; g++) {
                    const gen = instGens[g];
                    zone.generators[gen.oper] = gen.amount;
                }

                // Generator 53 is sample index
                if (zone.generators[53] !== undefined) {
                    zone.sampleIndex = zone.generators[53];
                }
                // Key range (43), Vel range (44)
                if (zone.generators[43] !== undefined) {
                    zone.keyLo = zone.generators[43] & 0xFF;
                    zone.keyHi = (zone.generators[43] >> 8) & 0xFF;
                }
                if (zone.generators[44] !== undefined) {
                    zone.velLo = zone.generators[44] & 0xFF;
                    zone.velHi = (zone.generators[44] >> 8) & 0xFF;
                }

                inst.zones.push(zone);
            }
        }
    }
}
